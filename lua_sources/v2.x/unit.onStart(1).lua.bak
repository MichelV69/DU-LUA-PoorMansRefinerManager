--- ### unit.onstart(1) --- 
desiredOreLoadInStock = 5400 --export: Maintain how much of each?
cycleTimeSeconds = 7 --export: Check connected industry how often?
t1_ore = false --export: Do we handle T1 raw ore?
t2_ore = false --export: Do we handle T2 raw ore?
t3_ore = false --export: Do we handle T3 raw ore?

t1_pure = true --export: Do we handle T1 refined ores (Pures)?
t2_pure = true --export: Do we handle T2 refined ores (Pures)?
t3_pure = false --export: Do we handle T3 refined ores (Pures)?

t1_products = false --export: Do we handle T1 processed materials (Products)?
t2_products = false --export: Do we handle T2 processed materials (Products)?
t3_products = false --export: Do we handle T3 processed materials (Products)?

forceBottomStart = true --export: Always start at the beginning when turned on.
                                    
version = "2.0.0"
rev_date = "29sep2025"

function switch_product(industryID)

    local currentState = industryID.getState()
    if currentState == IndustryStatus.storagefull	or 
       currentState == IndustryStatus.badconfig   or
       currentState == IndustryStatus.running
    then
      system.print(" skipping"..industryID.getLocalId()) 
      return
      end
                        
    local currentItemID = industryID.getOutputs()[1].id
    local stopImmediate = false
    local stopDestructive = false
    industryID.stop(stopImmediate, stopDestructive)

    system.print(" --------- ")
    system.print("industryID:"..industryID.getLocalId())
    system.print("currentState:"..currentState)
    system.print("currentItemID:"..currentItemID)
    system.print(" ")
  
    -- linked list to cycle possible recipes
    local cycleList = {}
    local fallback = ""

    if t1_ore then 
      cycleList[#cycleList + 1] = Materials.t1.ores.bauxite 
      cycleList[#cycleList + 1] = Materials.t1.ores.coal 	  
      cycleList[#cycleList + 1] = Materials.t1.ores.hematite      
      cycleList[#cycleList + 1] = Materials.t1.ores.quartz
      if fallback == "" then
        fallback = Materials.t1.ores.bauxite
        end
      
 	  end

    if t2_ore then 
      cycleList[#cycleList + 1] = Materials.t2.ores.chromite 
      cycleList[#cycleList + 1] = Materials.t2.ores.natron	 
      cycleList[#cycleList + 1] = Materials.t2.ores.malachite      
      cycleList[#cycleList + 1] = Materials.t2.ores.limestone
      if fallback == "" then
        fallback = Materials.t2.ores.chromite
        end
 	  end

    if t3_ore then 
      cycleList[#cycleList + 1] = Materials.t3.ores.pyrite     
      cycleList[#cycleList + 1] = Materials.t3.ores.acanthite  
      cycleList[#cycleList + 1] = Materials.t3.ores.garnierite       
      cycleList[#cycleList + 1] = Materials.t3.ores.petalite   
      if fallback == "" then
        fallback = Materials.t3.ores.pyrite 
        end
 	  end

    if t1_pure then 
      cycleList[#cycleList + 1] = Materials.t1.pures.aluminium
      cycleList[#cycleList + 1] = Materials.t1.pures.carbon 	
      cycleList[#cycleList + 1] = Materials.t1.pures.iron 	        
      cycleList[#cycleList + 1] = Materials.t1.pures.silicon
      if fallback == "" then
        fallback =  Materials.t1.pures.aluminium 
        end
     end

    if t2_pure then 
      cycleList[#cycleList + 1] = Materials.t2.pures.chromium
      cycleList[#cycleList + 1] = Materials.t2.pures.copper	 
      cycleList[#cycleList + 1] = Materials.t2.pures.sodium       
      cycleList[#cycleList + 1] = Materials.t2.pures.calcium 
      if fallback == "" then
        fallback = Materials.t2.pures.chromium 
        end            
 	  end

    if t3_pure then 
      cycleList[#cycleList + 1] = Materials.t3.pures.lithium
      cycleList[#cycleList + 1] = Materials.t3.pures.nickel	
      cycleList[#cycleList + 1] = Materials.t3.pures.sulfur      
      cycleList[#cycleList + 1] = Materials.t3.pures.silver 
      if fallback == "" then
        fallback = Materials.t3.pures.lithium 
        end                  
 	  end

    if t1_products then 
      cycleList[#cycleList + 1] = Materials.t1.products.alfealloy
      cycleList[#cycleList + 1] = Materials.t1.products.silumin  
      cycleList[#cycleList + 1] = Materials.t1.products.steel          
      if fallback == "" then
        fallback = Materials.t1.products.alfealloy 
        end                  
 	  end

    if t2_products then 
      cycleList[#cycleList + 1] = Materials.t2.products.calciumreinforcedcopper
      cycleList[#cycleList + 1] = Materials.t2.products.stainlesssteel         
      cycleList[#cycleList + 1] = Materials.t2.products.duralumin 
      if fallback == "" then
        fallback = Materials.t2.products.calciumreinforcedcopper 
        end                        
 	  end

    if t3_products then 
      cycleList[#cycleList + 1] = Materials.t3.products.allialloy
      cycleList[#cycleList + 1] = Materials.t3.products.cuagalloy
      cycleList[#cycleList + 1] = Materials.t3.products.inconel    
      if fallback == "" then
        fallback = Materials.t3.products.allialloy 
        end       
 	  end

    if forceBottomStart then
        forceBottomStart = false
        currentItemID = fallback
        end    

    local idToSet = 0
    --local loop = 0
    for loop , element in ipairs(cycleList) do
      -- loop = loop +1
      if element == currentItemID then
        idToSet = cycleList[loop+1] 
        end
      end

    if idToSet == 0 then
      idToSet = fallback
    end
    
    -- handle the refiner
    
    system.print(" idToSet:" .. idToSet) 
    industryID.setOutput(idToSet)
    industryID.startMaintain(desiredOreLoadInStock) 

    end


--- ### main code

IndustryList = {}
for i = 1, 9, 1 do
  if SlotList[i] and SlotList[i].getState() ~= nil then
    table.insert(IndustryList, SlotList[i])
    SlotList[i].stop(true)
  end
end

unit.setTimer("CheckStatus", 1)	
--- EOF unit.onstart(1) --- 

